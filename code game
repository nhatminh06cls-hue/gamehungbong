import pygame
import cv2
import mediapipe as mp
import numpy as np
import sys
import random
import math
from pygame.locals import *

# Khởi tạo Pygame
pygame.init()

WIDTH, HEIGHT = 1000, 700
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Game Hứng Bóng: Xóa Phông & Trí Nhớ")

# --- MÀU SẮC ---
BACKGROUND = (20, 20, 35)
WHITE = (255, 255, 255)
RED = (255, 50, 50)
GREEN = (50, 255, 100)
YELLOW = (255, 255, 50)

# Định nghĩa màu riêng cho bóng
C_BLUE   = (50, 150, 255)
C_RED    = RED
C_PURPLE = (180, 50, 255)
C_YELLOW = (255, 220, 50)

COLOR_DATA = {
    "XANH": (C_BLUE,   [(100, 200, 255), (0, 100, 200)]),
    "DO":   (C_RED,    [(255, 100, 100), (200, 0, 0)]),
    "TIM":  (C_PURPLE, [(220, 100, 255), (150, 0, 200)]),
    "VANG": (C_YELLOW, [(255, 255, 150), (220, 180, 0)])
}
ALL_COLORS = list(COLOR_DATA.keys())

# --- CLASS BUTTON (CHO MENU) ---
class Button:
    def __init__(self, text, x, y, width, height, color, hover_color, action=None):
        self.text = text
        self.rect = pygame.Rect(x, y, width, height)
        self.color = color
        self.hover_color = hover_color
        self.action = action
        try:
            self.font = pygame.font.SysFont("Segoe UI", 30, bold=True)
        except:
            self.font = pygame.font.SysFont("Arial", 30, bold=True)

    def draw(self, screen):
        mouse_pos = pygame.mouse.get_pos()
        click = pygame.mouse.get_pressed()
        if self.rect.collidepoint(mouse_pos):
            pygame.draw.rect(screen, self.hover_color, self.rect, border_radius=12)
            if click[0] == 1 and self.action:
                self.action()
        else:
            pygame.draw.rect(screen, self.color, self.rect, border_radius=12)
        pygame.draw.rect(screen, WHITE, self.rect, 2, border_radius=12)
        txt_surf = self.font.render(self.text, True, WHITE)
        screen.blit(txt_surf, (self.rect.centerx - txt_surf.get_width()//2, self.rect.centery - txt_surf.get_height()//2))

# --- HAND TRACKER (XÓA PHÔNG + FIX CRASH) ---
class HandTracker:
    def __init__(self):
        self.mp_hands = mp.solutions.hands
        self.mp_drawing = mp.solutions.drawing_utils
        self.mp_drawing_styles = mp.solutions.drawing_styles
        self.hands = self.mp_hands.Hands(static_image_mode=False, max_num_hands=1, min_detection_confidence=0.5, min_tracking_confidence=0.5)
        
        # Thêm Selfie Segmentation để xóa phông
        self.mp_selfie_segmentation = mp.solutions.selfie_segmentation
        self.segmenter = self.mp_selfie_segmentation.SelfieSegmentation(model_selection=1)
        
        self.cap = cv2.VideoCapture(0)
        self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
        self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
        self.current_frame = None
        self.last_valid_x = WIDTH // 2
        self.last_valid_y = HEIGHT - 80
        
    def get_hand_position(self):
        ret, frame = self.cap.read()
        if not ret: return self.last_valid_x, self.last_valid_y, False, None
        
        frame = cv2.flip(frame, 1)
        self.current_frame = frame
        
        image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = self.hands.process(image_rgb)
        
        landmarks = None
        is_fist = False
        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                landmarks = hand_landmarks
                wrist = hand_landmarks.landmark[0]
                h, w, _ = frame.shape
                MARGIN = 0.15
                normalized_x = (wrist.x - MARGIN) / (1 - 2 * MARGIN)
                normalized_x = max(0, min(1, normalized_x))
                self.last_valid_x = int(normalized_x * WIDTH)
                self.last_valid_y = int(wrist.y * h * (HEIGHT / h))
                is_fist = self.detect_fist(hand_landmarks)
                break
        return self.last_valid_x, self.last_valid_y, is_fist, landmarks
    
    def detect_fist(self, landmarks):
        wrist = landmarks.landmark[0]
        tips = [4, 8, 12, 16, 20]
        def dist(p1, p2): return math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2)
        return sum(1 for t in tips if dist(landmarks.landmark[t], wrist) < 0.15) >= 4

    def get_frame_for_display(self):
        if self.current_frame is not None:
            # 1. Resize
            small_frame = cv2.resize(self.current_frame, (320, 240))
            h, w, _ = small_frame.shape
            
            # 2. Xử lý xóa phông
            image_rgb = cv2.cvtColor(small_frame, cv2.COLOR_BGR2RGB)
            results = self.segmenter.process(image_rgb)
            mask = results.segmentation_mask > 0.5
            
            # 3. Tạo buffer RGBA thủ công (Fix lỗi crash surfarray)
            rgba_image = np.zeros((h, w, 4), dtype=np.uint8)
            rgba_image[:, :, :3] = small_frame # Copy màu BGR từ ảnh gốc
            rgba_image[:, :, 3] = np.where(mask, 255, 0).astype(np.uint8) # Alpha channel
            
            # 4. Chuyển BGR sang RGB cho đúng màu Pygame
            rgba_image = cv2.cvtColor(rgba_image, cv2.COLOR_BGRA2RGBA)
            
            # 5. Tạo Surface an toàn bằng frombuffer
            surface = pygame.image.frombuffer(rgba_image.tobytes(), (w, h), 'RGBA')
            
            return surface
        return None
    
    def release(self):
        self.cap.release()
        self.hands.close()

# --- PADDLE ---
class Paddle:
    def __init__(self):
        self.width = 160
        self.height = 25
        self.x = WIDTH // 2 - self.width // 2
        self.y = HEIGHT - 80
        self.is_fist = False
        self.target_x = self.x
        self.smooth_speed = 0.2
        
    def update(self, hand_x, hand_y, is_fist):
        self.is_fist = is_fist
        if hand_x is not None:
            self.target_x = hand_x - self.width // 2
            self.x += (self.target_x - self.x) * self.smooth_speed
            self.x = max(0, min(self.x, WIDTH - self.width))
    
    def draw(self, screen):
        color = RED if self.is_fist else GREEN
        status_text = "NẮM (FIST)" if self.is_fist else "DUỖI (OPEN)"
        glow = pygame.Surface((self.width + 30, self.height + 30), pygame.SRCALPHA)
        pygame.draw.rect(glow, (*color, 100), (0, 0, self.width + 30, self.height + 30), border_radius=15)
        screen.blit(glow, (self.x - 15, self.y - 15))
        pygame.draw.rect(screen, color, (self.x, self.y, self.width, self.height), border_radius=5)
        pygame.draw.rect(screen, WHITE, (self.x, self.y, self.width, self.height), 2, border_radius=5)
        font = pygame.font.SysFont("Arial", 18, bold=True)
        txt_surf = font.render(status_text, True, WHITE)
        screen.blit(txt_surf, (self.x + self.width//2 - txt_surf.get_width()//2, self.y - 25))

# --- BALL ---
class Ball:
    def __init__(self, level=1):
        self.radius = 24
        self.level = level
        self.color_key = None
        self.reset()
        self.trail = []
        
    def reset(self):
        self.x = random.randint(60, WIDTH - 60)
        self.y = random.randint(-800, -100)
        spd = 7 + (self.level * 0.5)
        self.speed_x = random.uniform(-spd, spd)
        self.speed_y = random.uniform(spd, spd + 3)
        self.rotation = 0
        self.old_y = self.y
        self.set_random_color()

    def set_random_color(self):
        pool = ALL_COLORS.copy()
        if self.color_key in pool: pool.remove(self.color_key)
        self.color_key = random.choice(pool)
        self.color_gradient = COLOR_DATA[self.color_key][1]
        self.main_color = COLOR_DATA[self.color_key][0]

    def update(self):
        self.old_y = self.y
        self.trail.append((self.x, self.y, self.color_gradient))
        if len(self.trail) > 10: self.trail.pop(0)
        self.x += self.speed_x
        self.y += self.speed_y
        self.rotation += 5
        if self.x <= self.radius or self.x >= WIDTH - self.radius:
            self.speed_x = -self.speed_x * 0.95
            self.x = max(self.radius, min(self.x, WIDTH - self.radius))
        if self.y <= self.radius and self.y > -50:
            self.y = self.radius
            self.speed_y = abs(self.speed_y)
    
    def draw(self, screen):
        for i, (tx, ty, grad) in enumerate(self.trail):
            alpha = int(150 * (i/len(self.trail)))
            sz = int(self.radius * (i/len(self.trail)))
            if sz > 0:
                s = pygame.Surface((sz*2, sz*2), pygame.SRCALPHA)
                pygame.draw.circle(s, (*grad[1], alpha), (sz, sz), sz)
                screen.blit(s, (tx-sz, ty-sz))
        pygame.draw.circle(screen, WHITE, (int(self.x), int(self.y)), self.radius + 3)
        pygame.draw.circle(screen, self.main_color, (int(self.x), int(self.y)), self.radius)
        pygame.draw.circle(screen, (255, 255, 255, 100), (int(self.x - 5), int(self.y - 5)), 6)

    def check_collision(self, paddle, rules):
        phys_hit = (self.x + self.radius >= paddle.x and 
                    self.x - self.radius <= paddle.x + paddle.width and
                    self.speed_y > 0 and 
                    self.y + self.radius >= paddle.y and 
                    self.old_y + self.radius <= paddle.y + 20)
        if phys_hit:
            required_action = "NAM" if self.color_key in rules["NAM"] else "DUOI"
            player_action = "NAM" if paddle.is_fist else "DUOI"
            if player_action != required_action:
                return False 
            self.y = paddle.y - self.radius - 1
            rel_x = (paddle.x + paddle.width/2) - self.x
            self.speed_x = -(rel_x / (paddle.width/2)) * 10
            self.speed_y = -min(abs(self.speed_y) * 1.15, 22)
            self.set_random_color()
            return True
        return False

# --- PARTICLE ---
class Particle:
    def __init__(self, x, y, color):
        self.x, self.y = x, y
        self.color = color
        self.size = random.randint(3, 6)
        self.vx, self.vy = random.uniform(-6, 6), random.uniform(-6, 6)
        self.life = 25
    def update(self):
        self.x += self.vx; self.y += self.vy; self.vy += 0.3; self.life -= 1
        return self.life > 0
    def draw(self, screen):
        alpha = int(255 * (self.life/25))
        s = pygame.Surface((self.size*2, self.size*2), pygame.SRCALPHA)
        pygame.draw.rect(s, (*self.color, alpha), (0,0,self.size*2, self.size*2))
        screen.blit(s, (self.x, self.y))

# --- GAME MANAGER ---
class Game:
    def __init__(self):
        self.hand_tracker = HandTracker()
        self.paddle = Paddle()
        self.balls = []
        self.particles = []
        self.score = 0
        self.lives = 5
        self.level = 1
        self.state = "MENU"
        self.rule_start_time = 0
        
        try:
            self.font_L = pygame.font.SysFont("Segoe UI", 72, bold=True)
            self.font_M = pygame.font.SysFont("Segoe UI", 36, bold=True)
            self.font_S = pygame.font.SysFont("Segoe UI", 20, bold=True)
        except:
            self.font_L = pygame.font.SysFont("Arial", 72, bold=True)
            self.font_M = pygame.font.SysFont("Arial", 36, bold=True)
            self.font_S = pygame.font.SysFont("Arial", 20, bold=True)

        self.screen_shake = 0
        self.rules = {"NAM": [], "DUOI": []}
        
        btn_w, btn_h = 250, 60
        cx = WIDTH // 2 - btn_w // 2
        self.btn_play = Button("CHƠI NGAY", cx, 300, btn_w, btn_h, (0, 150, 0), (0, 200, 0), self.action_play)
        self.btn_tut = Button("HƯỚNG DẪN", cx, 400, btn_w, btn_h, (0, 100, 200), (50, 150, 255), self.action_tutorial)
        self.btn_back = Button("QUAY LẠI", 50, 50, 150, 50, (100, 100, 100), (150, 150, 150), self.action_back_menu)

    def action_play(self):
        self.score = 0
        self.lives = 5
        self.level = 1
        self.balls.clear()
        self.balls.append(Ball(self.level))
        self.generate_rules()
        self.state = "SHOW_RULES"
        self.rule_start_time = pygame.time.get_ticks()

    def action_tutorial(self):
        self.state = "TUTORIAL"

    def action_back_menu(self):
        self.state = "MENU"

    def generate_rules(self):
        colors = ALL_COLORS.copy()
        random.shuffle(colors)
        self.rules["NAM"] = colors[:2]
        self.rules["DUOI"] = colors[2:]

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == QUIT: return False
            if event.type == KEYDOWN:
                if event.key == K_ESCAPE: 
                    if self.state == "PLAYING" or self.state == "SHOW_RULES":
                        self.state = "MENU"
                    else:
                        return False
                if event.key == K_r and self.state == "GAME_OVER": 
                    self.action_play()
        return True
    
    def update(self):
        hx, hy, is_fist, _ = self.hand_tracker.get_hand_position()
        self.paddle.update(hx, hy, is_fist)
        
        if self.state == "MENU": pass 
        elif self.state == "SHOW_RULES":
            if pygame.time.get_ticks() - self.rule_start_time > 5000:
                self.state = "PLAYING" 
        elif self.state == "PLAYING":
            ball = self.balls[0]
            ball.update()
            if ball.check_collision(self.paddle, self.rules):
                self.score += 10
                self.screen_shake = 10
                for _ in range(15): 
                    self.particles.append(Particle(ball.x, ball.y, COLOR_DATA[ball.color_key][0]))
                if self.score > 0 and self.score % 50 == 0:
                    self.level += 1
                    ball.level = self.level
                    self.generate_rules()
                    self.state = "SHOW_RULES"
                    self.rule_start_time = pygame.time.get_ticks()
                    ball.reset()
            if ball.y > HEIGHT + 50:
                self.lives -= 1
                if self.lives <= 0: self.state = "GAME_OVER"
                else:
                    self.balls.clear()
                    self.balls.append(Ball(self.level))

        self.particles = [p for p in self.particles if p.update()]
        self.screen_shake = max(0, self.screen_shake - 0.5)

    def draw(self):
        sx = random.randint(-int(self.screen_shake), int(self.screen_shake))
        sy = random.randint(-int(self.screen_shake), int(self.screen_shake))
        
        screen.fill(BACKGROUND)
        for i in range(0, WIDTH, 50): pygame.draw.line(screen, (40,40,60), (i,0), (i,HEIGHT))
        for i in range(0, HEIGHT, 50): pygame.draw.line(screen, (40,40,60), (0,i), (WIDTH,i))
        
        for p in self.particles: p.draw(screen)
        
        if self.state == "PLAYING" or self.state == "GAME_OVER":
            if self.balls: self.balls[0].draw(screen)
        
        self.paddle.draw(screen)
        
        # --- WEBCAM ĐÃ XÓA PHÔNG & FIX LỖI CRASH ---
        frame = self.hand_tracker.get_frame_for_display()
        if frame:
            screen.blit(frame, (WIDTH-330, 10))
            pygame.draw.rect(screen, (100,200,255), (WIDTH-332, 8, 324, 244), 1)

        if self.state == "MENU": self.draw_menu()
        elif self.state == "TUTORIAL": self.draw_tutorial()
        elif self.state == "SHOW_RULES": self.draw_rule_phase()
        elif self.state == "PLAYING": self.draw_hud()
        elif self.state == "GAME_OVER": self.draw_game_over()

        if sx!=0 or sy!=0: screen.blit(screen, (sx,sy))

    def draw_menu(self):
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        overlay.fill((0,0,0,150))
        screen.blit(overlay, (0,0))
        t1 = self.font_L.render("PHẢN XẠ", True, (100,255,255))
        t2 = self.font_L.render("MÀU SẮC", True, (255,100,255))
        screen.blit(t1, (WIDTH//2 - t1.get_width()//2, 100))
        screen.blit(t2, (WIDTH//2 - t2.get_width()//2, 180))
        self.btn_play.draw(screen)
        self.btn_tut.draw(screen)

    def draw_tutorial(self):
        screen.fill((10, 10, 20))
        t = self.font_L.render("HƯỚNG DẪN", True, (255,255,0))
        screen.blit(t, (WIDTH//2 - t.get_width()//2, 50))
        lines = [
            "1. GAMEPLAY TRÍ NHỚ:",
            "   - Đầu màn, bảng luật sẽ hiện trong 5 GIÂY.",
            "   - Hãy nhớ màu nào cần NẮM, màu nào cần DUỖI.",
            "",
            "2. ĐIỀU KHIỂN:",
            "   - Nắm tay (Fist) hoặc Duỗi tay (Open).",
            "   - Đỡ sai tay -> Bóng xuyên qua -> Mất mạng.",
            "",
            "3. WEBCAM:",
            "   - Đã được xóa phông để dễ nhìn bóng rơi!"
        ]
        for i, line in enumerate(lines):
            txt = self.font_M.render(line, True, WHITE)
            screen.blit(txt, (100, 150 + i*40))
        self.btn_back.draw(screen)

    def draw_rule_phase(self):
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        overlay.fill((0,0,0,220))
        screen.blit(overlay, (0,0))
        remain = 5 - (pygame.time.get_ticks() - self.rule_start_time) // 1000
        t_time = self.font_L.render(f"BẮT ĐẦU SAU: {remain}", True, (255,255,0))
        screen.blit(t_time, (WIDTH//2 - t_time.get_width()//2, 50))
        
        cy = HEIGHT // 2
        pygame.draw.rect(screen, (50, 20, 20), (WIDTH//2 - 230, cy - 100, 220, 200), border_radius=15)
        pygame.draw.rect(screen, RED, (WIDTH//2 - 230, cy - 100, 220, 200), 3, border_radius=15)
        screen.blit(self.font_M.render("NẮM TAY", True, RED), (WIDTH//2 - 180, cy - 80))
        for i, ckey in enumerate(self.rules["NAM"]):
            col = COLOR_DATA[ckey][0]
            pygame.draw.circle(screen, col, (WIDTH//2 - 170 + i*100, cy + 20), 40)
            pygame.draw.circle(screen, WHITE, (WIDTH//2 - 170 + i*100, cy + 20), 40, 3)

        pygame.draw.rect(screen, (20, 50, 20), (WIDTH//2 + 10, cy - 100, 220, 200), border_radius=15)
        pygame.draw.rect(screen, GREEN, (WIDTH//2 + 10, cy - 100, 220, 200), 3, border_radius=15)
        screen.blit(self.font_M.render("DUỖI TAY", True, GREEN), (WIDTH//2 + 50, cy - 80))
        for i, ckey in enumerate(self.rules["DUOI"]):
            col = COLOR_DATA[ckey][0]
            pygame.draw.circle(screen, col, (WIDTH//2 + 70 + i*100, cy + 20), 40)
            pygame.draw.circle(screen, WHITE, (WIDTH//2 + 70 + i*100, cy + 20), 40, 3)

    def draw_hud(self):
        # UI đã chuyển lên góc trên bên trái, được tách dòng
        pygame.draw.rect(screen, (0,0,0), (10, 10, 280, 150), border_radius=10)
        pygame.draw.rect(screen, (100,255,255), (10, 10, 280, 150), 2, border_radius=10)
        
        # Dòng 1: Điểm
        screen.blit(self.font_M.render(f"ĐIỂM: {self.score}", True, (50,255,100)), (25, 20))
        
        # Dòng 2: Mạng
        screen.blit(self.font_M.render(f"MẠNG: {self.lives}", True, (255,50,50)), (25, 60))
        
        # Dòng 3: Level (Đã xuống dòng)
        screen.blit(self.font_M.render(f"LEVEL: {self.level}", True, (255,255,50)), (25, 100))

    def draw_game_over(self):
        overlay = pygame.Surface((WIDTH, HEIGHT), pygame.SRCALPHA)
        overlay.fill((0,0,0,220))
        screen.blit(overlay, (0,0))
        t1 = self.font_L.render("GAME OVER", True, (255,50,50))
        t2 = self.font_M.render(f"Điểm số: {self.score}", True, (255,255,50))
        t3 = self.font_S.render("Nhấn R để chơi lại", True, WHITE)
        screen.blit(t1, (WIDTH//2 - t1.get_width()//2, HEIGHT//3))
        screen.blit(t2, (WIDTH//2 - t2.get_width()//2, HEIGHT//2))
        screen.blit(t3, (WIDTH//2 - t3.get_width()//2, HEIGHT//2 + 60))

    def cleanup(self):
        self.hand_tracker.release()

def main():
    clock = pygame.time.Clock()
    game = Game()
    running = True
    while running:
        running = game.handle_events()
        game.update()
        game.draw()
        pygame.display.flip()
        clock.tick(60)
    game.cleanup()
    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
